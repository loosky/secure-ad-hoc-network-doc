\chapter{System Design}
\label{ch:design}
\acresetall

This chapter portrays the design for the proposed implementation of the secure
ad hoc network.

\section{Brief Overview}
The design here is based on a functional pro-active ad hoc routing protocol. The
routing is left to the chosen routing protocol, i.e. \ac{BATMAN}, and the
changes made will not affect how the routing is performed. The system design can
be said to be an extension of the protocol, which requires nodes to be
authenticated and trusted before being allowed into the network. To strengthen
the system each node also has to verify their identity periodically, or they are
dropped from the network.


\subsection{Initial Authentication}
The network setup start with an out-of-band authentication where a master node,
hereafter \ac{SP}, verifies new nodes. How this is done can be up to the
application, but let us assume that the actors carrying their communication
devices, hereafter nodes, physically meets the \ac{SP} at the scene and verifies
each others public keys out-of-band.

When a new node is discovered by the \ac{SP} using regular routing announcements
as part of the pro-active routing protocol, the \ac{SP} will invite the new node
to a handshake to establish a trust between the two nodes. The new node will
receive the \ac{SP}'s certificate (proxy certificate), and will after verifying
public key requests a proxy certificate itself. After verifying the node's
public key, the \ac{SP} issues a proxy certificate with (possibly) the rights to
participate in building the \ac{MANET} by broadcasting its own and
re-broadcasting other trusted nodes' routing announcements.

\subsection{Continuous Authentication}
After being issued with a \ac{PC} the newly authenticated node will periodically
``broadcast'' - unicast to each neighbor - a message containing an ephemeral key
and corresponding \ac{IV}, a pseudo-randomly generated nonce, and a signature (HMAC)
of this message. It is important to note that the ephemeral key is encrypted
with the neighbor's public key (hence multiple unicasts instead of an actual
broadcast), but the HMAC is generated using the unencrypted key (to avoid
generating a HMAC for each neighbor).

After sending this signed ``broadcast" to each neighbor, the node and its
neighbors will generate a keystream from the ephemeral key, , and nonce. The
node will then append two new bytes from this keystream to each routing
announcement, and re-broadcasts of neighbors announcements, sent from this point
forward with a sequence number for the recipient to be able to match this
``extract'' with the keystream at an offset given by the sequence number.

The neighbors will only accept a routing announcement if and only if:

\begin{itemize}
  \item the routing announcement is appended with a key extract and,
  \item it matches the keystream at the sequence number offset and,
  \item the sequence number has not been received earlier (replay).
\end{itemize}

This ``key extract'' of the keystream is comparable to regular one-time-password
as used by e.g. online banks [TODO: ref?] and it is important to note that they
are not ``connected'' to the announcements sent, meaning they do not
provide integrity for the packet.

Whenever a routing announcement is re-broadcasted by another trusted node, that
node will change the key extract, or one-time-password, appended to the
announcement to an extract from its own keystream. This means that every node
only checks its direct neighbor for authentication, which is a design choice.
This proposal assumes that because every node is verified by the \ac{SP} in the
first place, all nodes in the network will be able to trust each other, which
also means they will trust their neighbors to properly verify their neighbors
again. This technique also helps prevent a wormhole attack, which will be
discussed later.

%In order for trusted nodes to learn of newly trusted nodes existence, the
%\ac{SP} reularly broadcasts lists containing the id, address and public key of
%each trusted node in the network. This needs to be done, because before
%learning about a new node the other trusted nodes will not accept any messages
%from this node. This means the new node will not be able to exchange its own
%\ac{PC} with other nodes directly - only through the \ac{SP}.

When a trusted node discover a new neighbor, which is a trusted node in the
network - they first have to exchange their \acp{PC} and verify the signatures
on the certificates. Their knowledge of the corresponding private keys to their
\acp{PC} are only indirectly verified because they need to know the private key
in order to decrypt the ephemeral keys sent with the signed broadcasts by their
neighbors. Each of the two nodes then stores the other's public key, subject
name, id, and address in a list called \ac{AL}.

%The list, hereafter \ac{AL}, also adds some \ac{WOT} like capabilities. The
%list is signed by the \ac{SP}, which means the integrity of the list is
%guaranteed by the \ac{SP}. This means that if the \ac{SP} should go offline,
%e.g. it could be out of range, other trusted nodes in the \ac{MANET} can
%continue to broadcast the \ac{SP} on behalf of the \ac{SP} - to ensure all
%nodes in the network know each other. This can be especially important when the
%network grows large and become fully or partially separated and nodes in one
%part may not have learnt of the existence of newly trusted nodes yet. It also
%applies to trusted nodes who have been offline while new nodes have been
%verified, then re-enter the network while the \ac{SP} is offline. [TODO:
%kanskje ref til mitt eget essay?]

After a neighbor is added to the \ac{AL}, the node can then also add the
neighbor to another list, called a neighbor list. This list is used to keep
track of current direct neighbors and their current keystreams. While nodes in
the \ac{AL} is kept in that list throughout the lifetime of the network, or
until the lifetimes of the nodes have passed, a node in the neighbor list is
removed when it is no longer a direct neighbor. How to detect this will be
discussed later.

TODO: kanskje en figur som viser dette og?

\subsection{Why use Proxy Certificates?}
\acp{PC}, as described in Section \ref{sect:pc}, are used to delegate
rights on behalf of their issuers. That means that the issuer, i.e. the \ac{SP},
can chose to delegate all or a subset of its rights to the receiver of the
\ac{PC}. This can be very useful in a situation where the nodes themselves are
unable to properly authenticate themselves with their pre-existing \acp{LLPKC}
if the \ac{SP} on the scene has no way to verify their certificates. This can be
true if their certificates are issued by an unknown root certificate (\ac{CA})
or simply if there is no Internet access and the certificate is signed by an
unknown entity (unknown to the \ac{SP}), even if it knows and trusts the root
\ac{CA}.

Also, the \ac{SP} could be interested in giving the node rights the node would
not usually have on this specific scene, depending on the situation. This is
easier to achieve when the \ac{SP} can delegate its own rights.

An important feature of the \acp{PC} is that the \ac{SP} can delegate different
kinds of rights, as long as it is a subset of its own rights, to different
nodes. There are countless of different rights that can be useful, given the situation
they are used in, but here is a few possible rights/privileges to give the
reader an understanding of the possibilities they give:

\begin{itemize}
  \item Announce itself - let the \ac{MANET} know of your existence
  \item Re-broadcast other nodes announcements - reshape the network topology
  \item Announce a gateway - give the \ac{MANET} access to another network
  \item Use the gateway - allow you to communicate outside the \ac{MANET}
  \item Send and receive messages with a defined application - full application
  rights
  \item Only receive messages from a defined application - limited application
  rights
\end{itemize}

The different choices are essentially up to the \ac{SP} managing the network.
One can ask why this is necessary, and again it depends on the application. If
you are setting up a \ac{MANET} on the scene of a disaster to assist emergency
personnel, you could have some actors be able to organize the effort by sending
orders/commands to the other actors, while some actors only are allowed to
receive the orders. In this situation it might be of great importance to know
that only verified nodes are able to give commands, but the importance of
getting this information available outweighs the need to verify the nodes/actors
receiving this information.

Lastly but not least, proxy certificates commonly have short valid lifetime
compared to regular certificates, meaning an implementation using proxy
certificates does not necessarily need to implement a certificate revocation
scheme, which makes for less management operations in the management-hostile
envirnontment that is \acp{MANET}.


\section{Requirements}
Ad hoc networks have some desired characteristics such as quick and inexpensive
setup and being independent of communication infrastructure, but they also
impose great challenges regarding security. The challenges regarding security
can vary depending the purpose and environment of the network which will be
covered in this section.

\subsection{Scenario}
The design and implementation presented in this thesis is mostly based on an
emergency situation scenario, in which communication infrastructure is
unavailable. This thesis will also reflect on some possible requirements given
by a military application.

If there is a major emergency situation such as an earthquake or tsunami, it is
likely that parts or the entire communication infrastructure at the scene
is destroyed or temporarily down. The remaining communication lines will then
probably be congested, such that little communication actually goes through
[TODO: find a ref].

In this situation, it is of great importance that Emergency Personnel, such as
Paramedics, Firemen, Policemen and the Military, are able to communicate
efficiently and therefore independently of the public communication
infrastructure. They need this network in order to manage the the operation, and
therefore availability is probably the most important trait of this network.
Secondly, they should be able to trust the communication on the network - i.e.
messages sent are from whom they claim they to be.

Also, being able to authorize new actors on the scene, such as Red Cross, can be
critical to the operation. These new actors will probably not have the necessary
authentication tokens, i.e. certificates, required by the authentication scheme
in the network.

\subsection{List of Requirements}
Based on the scenario above these requirements can be extracted and made into
general requirements that needs to be addressed by the system design. The work
presented here is based on several sources, most prevalent being the research
from the OASIS project \cite{oasis_report} \cite{5683058} \cite{nyre2009secure}
and the doctoral project of Eli Winjum carried out at UniK
\cite{ffi_2005_04015}.

\begin{table}[ht!]
	\centering
	%\begin{tabular}{ | l | p{11cm} | }
	\begin{tabular*}{\textwidth}{ | p{5mm} | p{388pt} | }
	\hline
	\textbf{\#} & \textbf{Requirement Description}\\\hline
		R1 & A node must be authorized in order to get full rights in a network \cite{dahill2001secure}, \cite{sanzgiri2002secure}\\\hline
		R2 & A node without a recognized authentication token should be able to become authorized if necessary\\\hline
		R3 & Networks need a master node to handle authentication of new nodes\\\hline
		R4 & Access control (after initial authentication) should work without centralized nodes\\\hline
		R5 & Different networks should be able to collaborate \cite{ffi_2005_04015}\\\hline
		R6 & Only master nodes can decide access policies of users/nodes\\\hline
		R7 & Nodes must not be able to alter their access policies\\\hline
	\end{tabular*}
	\caption{Requirements based upon our simplified and general scenario.}
	\label{tab:our_req}
\end{table}

An early study produced security requirements of ad hoc networks demanding
that the routing logic must not be spoofed or altered to produce different
behavior \cite{dahill2001secure}. R1 is constructed from that requirement.
During the OASIS project, a requirement ensuring different actors such as
police, fire and medical professionals can participate in the network, gives R2
\cite{5683058}.

Because of R2 there needs to be some sort of authority managing the
authentication and access management, which leads to R3. However, verifying
nodes access rights after the fact should be possible even without the
availability (R4) - also a requirement given by the OASIS project.

The doctoral project of Winjum recommends seamless radio coverage over the whole
crisis area, possibly requiring merging or at least collaboration between
different networks, R5.

R7 comes implicitly from R6 because R6 would be useless if regular nodes could
alter their priveleges without the permission of a master or management node. R6
is necessary in this design as no authentication is required prior to the
network setup, and it is therefore no way to know which rights one actor/node
shuold have. As will be discussed in Chapter \ref{ch:discussion} the network
might also be able to recognize authentication tokens, such as long lived
certificates, issued prior to this setup. If this is the case, one might have to
re-evaluate these requirements.

The OASIS had another important requirement which is not covered here, but is
important to mention - there should be mechanisms in place to detect misbehaving
nodes, i.e. already trusted nodes that acts maliciously. This detection is not
covered in this thesis as pointed out in \ref{limit:malicious_behaviour}, but is
nevertheless important to take notice of.

\section{Design Overview}
The secure ad hoc network designed here does not change any fundamental workings
of regular ad hoc routing protocols. When nodes have been authenticated and
neighbors have verified their neighbors respectively, the routing annoucements
are generated, broadcasted, forwarded, and handled by the routing protocol as
usual.

The proposed design should work with most pro-active ad hoc routing protocols
operating on the network layer with limited alterations - but this design is
specifically made for the BATMAN \cite{batman_rfc} routing protocol chosen for
its simpler design compared to e.g. OLSR \cite{clausen2003rfc3626} and because
it operates on the third layer of the \ac{OSI} model \cite{zimmermann1980osi}.
Whether this design would work on a link-layer protocol is unknown, and there is
still a discussion whether having routing protocols on the link-layer is a good
thing, as it breaks the layering principles of the \ac{OSI} model
\cite{5680190}. How this design is incorporated, or added, to the BATMAN
protocol will be explained in Chapter \ref{ch:implementation}.

The basic principle of the proposed design is that an authenticated node accepts
other authenticated nodes' routing announcements and forwards them as normal, while
discarding routing announcements from unauthenticated nodes. One or more nodes in the
network will assume a role as master node(s), with the extra capability of
authorizing new nodes into the network. A special certificate called a \ac{PC}
\cite{rfc3820} will be used for authentication after this authorization has taken
place such that other nodes in the network will be able to authenticate and
accept the new node.

\subsection{Entity Explanation}
Before a simplified example can be given, a few new entities in this design
needs to be explained further. This is the short version, just enough for the
reader to understand the example - the full description of these entities
and why they are necessary will be given later. All of these entities are also
portrayed in Figure \ref{fig:simple_example_entities}. The portrayed entities
will be used as a template for other figures later in this thesis report.

\begin{itemize}
  \item \textbf{\acf{SP}} is responsible for tasks similar to that of a \ac{CA}
  	and has the master role in the network. The \ac{SP} is the entity that
 	 authorizes new nodes and signs their \acp{PC}.
  \item \textbf{\acf{PC0}} is a self-signed \ac{PC} belonging to a
  	\ac{SP}. This \ac{PC} has a certificate depth of 0, thus we refer to it as a
  	\ac{PC0}.
  \item \textbf{\acf{PC1}} is a \ac{PC} signed by a \ac{PC0} (i.e. by the
  private key of the \ac{SP}). All authenticated nodes in one network, has a
  \ac{PC1} signed by a \ac{SP} from that network.
  \item \textbf{\acf{AL}} is a list containing the necessary information about
 	all known and authorized nodes in the network. All nodes keep a local copy of
 	the \ac{AL} which they use to authenticate other nodes in the network.
  \item \textbf{Neighbor List} is a list containing the current trusted direct
    neighbors (must also be in \ac{AL}) with a copy of their keystreams used for
    verifying their routing announcements.
  \item \textbf{Authenticated Node} is a node which has been isseud a \ac{PC1}
    from the \ac{SP} and is considered a trusted node in the network. This node
    can take part in sending its own routing announcements and forwarding other
    authenticated nodes routing announcements, i.e. they take part in changing
    the network topology.
  \item \textbf{Unauthenticated Node} is a node which has not yet been
    authorized, or denied access, by the \ac{SP}. They do not possess a
    certificate for which the other nodes can verify, and its routing
    announcements are ignored by other trusted nodes in the network.
\end{itemize}

\begin{figure}[h]
	\centering
  	\includegraphics[width=\textwidth]{images/simple_example_entities.png}
  	\caption{Different entities in the Simple Example.}
	\label{fig:simple_example_entities}
\end{figure}

\subsection{Simple Example}
Two nodes are within transmitting range of each other, i.e. they are direct
neighbors. One of the nodes is a \ac{SP} and the other is unauthenticated. The
pro-active ad hoc routing protocol used on both nodes regularly broadcasts
routing announcements, so the two nodes learn of each others' existence. Upon
reception of a routing announcement from the unauthenticated node, the \ac{SP}
will invite the node for a handshake. The invite message contains the \ac{SP}'s
\ac{PC0} which assumably the unauthenticated node is able to verify , possibly
based on a prior out-of-band sharing of public key fingerprints.

After verifying the \ac{PC1}, the unauthenticated node will send a \ac{PC}
request with its own public key. If the \ac{SP} is able to verify the senders
public key (same assumption as above) and the \ac{SP} decides this node should
have access to network, it will create and sign \ac{PC} for this node - i.e. the
node is issued a \ac{PC1}.

%Before the \ac{SP} actually signs the \ac{PC} requested from the
%unauthenticated node, it needs some verification that the node is an actor that
%should be allowed access to the network. The actor will therefore meet the
%\ac{SP} in the field and give its public key fingerprint (out-of-band) so the
%\ac{SP} can verify the incoming public key in the \ac{PC} request as the
%actor's request.

%Using the public key of the \ac{PC1}, the newly trusted node will now create
%and broadcast a signature, and use an excerpt (offset value) from this
%signature in its routing announcements. The signature excerpt is just a value used
%in the following routing announcements, and not the cryptographic signature itself,
%but will be used for recognition. This will be described further later in the
%chapter. The \ac{SP}, recognizing the signature offset value will rebroadcast
%the routing announcements so regular ad hoc routing follows.

When the handshake completes both nodes will add the other node of the handshake
to their \ac{AL} - storing their id, address, unique subject name, role, and
public key.

At this point, both the newly authenticated/trusted node and the \ac{SP} will
send one another a message containing their current (or new in the case of the
trusted node) ephemeral key, \ac{IV}, nonce value and a signed hash value (HMAC) of
these values. The ephemeral key part is encrypted with the other's public key to
keep this information secret. The HMAC however, is computed over the unencrypted
key in order to re-use this signature if more nodes connect.

Both nodes can now generate two keystreams based on these values, their own and
the other node's keystream. These keystreams, address, id, an empty ``last
sequence number'', and an empty sliding window of the other node is then stored
in the neighbor list.

%Also upon handshake completion is the generation an \ac{AL}. The \ac{SP} will
%use this list in order to save certain necessary details about the other node,
%such as its address, public key, last signature, and more. Also in this list is
%the corresponding information about the \ac{SP} itself. When the list is
%created or updated it is broadcasted to the network - signed by the \ac{SP} to
%ensure no other node can alter the information about trusted nodes in the
%network.

From this point forward, the two nodes use an two-byte extract of the keystream
and append it together with a sequence number (for finding the correct offset
in keystream) to future routing announcements. This goes for both original
routing announcements from the node itself, and when they forward other trusted
nodes routing announcements. The two nodes never re-use the same extract from
the keystream, and they use a sliding window stored in their neighbor list to
keep track of which extracts they have received from their neighbor. This last
part is crucial in order to be able to drop announcements containing re-used
extracts, and therefore to avoid replay attacks. Once more, these key extracts
should be viewed as one-time-passwords, and must never be allowed to be re-used.

Whenever a new node is discovered by the \ac{SP} the procedure above repeats,
and a new addition is made to the \ac{AL} and neighbor list. Other previously
trusted nodes will learn the identity of new nodes when they discover the new
node and initiate in a ``keystream'' exchange - discussed later.

\begin{figure}[ht]
	\centering
  	\includegraphics[height=13cm]{images/simple_example_msc.png}
  	\caption{Message sequence chart of the simple example showing authentication
  	  handshake and keystream material sharing between SP and new node A. Routing
  	  announcements at the end contain one-time-passwords (OTP) from keystreams}
	\label{fig:simple_example_msc}
\end{figure}

Figure \ref{fig:simple_example_msc} shows a message sequence chart of the
messages sent between two nodes during the simple example. Routing announcements
without one-time-passwords are sent periodically throughout the sequence until
keystreams are generated, but this is left out of the figure as they do not
affect the nodes. Only the routing announcements in the beginning and in the end
(appended with one-time-passwords) are portrayed as they show how the handshake
is initiated (by discovery) and ended after successfully ending the handshake
and keystream material sharing.

If a new node enters transmitting range of the two nodes similar messages are
exchanged, as shown in Figure \ref{fig:simple_example_msc_2}.

\begin{figure}[h]
	\centering
  	\includegraphics[height=13cm]{images/simple_example_msc_2.png}
  	\caption{Message sequence chart of the simple example showing another node B
  	  attempting to join the network, and the messages between A and B after B
  	  is autneticated by the SP}
	\label{fig:simple_example_msc_2}
\end{figure}


\section{Node States/Phases?}
This section is devoted to explain the different states(/phases?) a node can be
in, and how it behaves during these different states(/phases?). These
states(/phases?) should be similar for most network layer pro-active routing
protocols as the main trigger of these phases is the routing announcements sent
as per normal operation of any pro-active routing protocol.

\subsection{Node Discovery}
TODO: Maybe some state-diagrams in this section as well?

Upon entering the network area, the node is both unauthenticated and unknown to
the network. Because it use a pro-active routing protocol, the node regularly
broadcasts routing announcements to be received by any potential node in the
area. At this point an assumption that all nodes are configured with unique
addresses and with the same netmask is done in order to focus on the security
challenges, rather the non-trivial task of assigning addresses in \acp{MANET}
(See Limitations in Section \ref{ip_address_conf}). With this assumption all
nodes within transmitting range of the new node can receive its broadcasts.

Simultaneously, the node also listens to other nodes' routing announcements.
Depending on the time interval between the broadcasts and whether the nodes
within each other's transmitting range are asymmetrical, they will discover each
other approximately at the same time.

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.6\textwidth]{images/node_states_discovery.png}
  	\caption{Discovery Phase between a \acf{SP} and an unauthenticated node (A)}
	\label{fig:node_states_discovery}
\end{figure}

Figure \ref{fig:node_states_discovery} illustrate the routing announcements
periodically sent by two nodes until they discover each other. One of the nodes
have already assumed the master role and is a \ac{SP} while the other node is
unauthenticated.

The \ac{SP} will have its own self-issued (and signed) \ac{PC0} and its \ac{AL}
has only one entry - its own \ac{PC0}. Note that if it had authorized another
node at an earlier point in time (but within the lifetime of the \ac{PC}) that
node's \ac{PC1} would also be represented in the \ac{AL}, even if the node was
outside the network at this point (physically).

The new node does not have any \ac{PC} at this point, unless it has a \ac{PC}
issued within and valid only for another network. This is however not covered
here, and it is assumed the node has no certificate at all. The same goes for
its \ac{AL}, or one can rather say it has an empty \ac{AL} - denoted by the
'\O' in the figure.

\subsection{Authentication Handshake}

\begin{figure}[h]
	\centering
  	\includegraphics[width=0.6\textwidth]{images/node_states_handshake.png}
  	\caption{Handshake between a \acf{SP} and an unauthenticated node A.}
	\label{fig:node_states_handshake}
\end{figure}

Once the two nodes have discovered each other, the \ac{SP} will enter an
authentication handshake state, while the unauthenticated node will not do
anything. The authentication handshake state of the \ac{SP}, and later of the
other node, does not obstruct regular routing announcements to be sent. The
current state only affects how the \ac{AM} operates, not how the original
routing protocol operates. Actually, the handshake and all other messages and
operations handled by the \ac{AM} is executed in a separate thread from the rest
of the protocol. This is further elaborated in the next chapter.

Because the unauthenticated node does not enter a new state upon the discovery
of the \ac{SP}, which could just be a regular authenticated node as well, there
will be no deadlock if for some reason the \ac{SP} should never initiate the
handshake, or invite to the handshake. This could happen for a multitude of
reasons being the two nodes looses their connectivity between each other
because of the flaky nature of wireless ad hoc networks, or the assumed \ac{SP}
was only a regular authenticated, trusted, node. From the routing announcements
it is not possible to derive whether a node is simply authenticated, or if it
also has master role capabilities being a \ac{SP}. It is only possible to
derive that a node is authenticated in some network or not.

%The unknown node will wait for a predefined amount of time, for it may not ever
%receive a request. The discovery might have been of an authenticated node with
%a \ac{PC1} and not a \ac{SP}, which does not have the rights to authenticate
%new nodes. It might also have been that of a \ac{SP}, but because of the flaky
%nature of ad hoc networks, the two nodes might have become invisible to each
%other before the handshake could be initiated.

While the new node is waiting for an invite, or simply not doing anything
interesting announcing its existence - the \ac{SP} generates an invite message
which is a message containing the public key, i.e. the \ac{PC0}. The invite
will be directly addressed to the new node, and not broadcasted as regular
routing announcements are. The \ac{SP} will then wait for a certificate request
(\ac{PC} Request) for a short predefined time before aborting the handshake and
entering its ready-state. If the two nodes discover each other once more, the
\ac{SP} will once again try to invite the other node to the handshake. If this
fails several times, the \ac{SP} will eventually ignore the all discoveries of
the other node (based on address) for a predefined time before it tries again.

If the new node is able to verify the public key received from the \ac{SP} in
the invite message it will use its public key pair and generate a \ac{PC}
request which it will send back. This request abides by the rules for making a
proxy certificate \cite{rfc3820}, setting the Issuer Name as the Subject Name
from the received \ac{PC0}, the Subject Name as the Issuer Name appended with
its own unique Common Name, which is the hash value of its own public key, and
the Serial Number from the same hash value.

These, and the last step of issuing the \ac{PC1} is shown in Figure
\ref{fig:node_states_handshake}. Before issuing the \ac{PC1} the \ac{SP}
verifies the public key received in the request message. As before, the
knowledge necessary to be able to verify the public key is assumed to have been
communicated out-of-band prior to this setup. The \ac{PC1} is appended with the
proxy policies the \ac{SP} seems fit for the node, and then signed with the
\ac{SP}'s private key. After sending the \ac{PC1} to the new node the \ac{SP}
will add the \ac{PC1} and other relevant data to its local \ac{AL} and the new
node will, after verifying the signature, store the issued certificate for
later.

\subsubsection*{Out-Of-Band Authentication}
Above, only brief mention was made to how the initial verification of each nodes
public keys were made. For this purpose, many authentication schemes have been
produced, but when it comes to \acp{MANET}, possibly with no Internet
connection, proper authentication becomes a difficult task. In the discussion
in Chapter \ref{ch:discussion} different schemes will be discussed, but here
only one ``scheme'' is accounted for.

If you have no pre-shared information between the parties involved in the
network, the simplest way to authenticate a new node is to use an out-of-band
authentication. The implementation of such an authentication scheme will be
discussed in the next chapter, and will only be briefly mentioned here.

In the PGP model new users will have to use share their public key fingerprint
with the \ac{SP} physically or through a different communication channel than
the one the authentication process is supposed to secure, and vice versa
\cite{zimmermann1995official}. By doing this, the \ac{SP} can store the
fingerprint and use it to check the received public key in the \ac{PC} request
for authenticity in order to make sure the new node is run by the actual person
he met and verified physically. The new node can similarly verify the \ac{SP}.

To implement this, the application running the routing protocol and the
authentication service could either read a file for ``allowed'' fingerprints, or
simply have user interaction with a pop-up window showing the fingerprint and
asking the user whether to trust the public key or not.

This implementation is relatively simple compared to the rest of the design, so
in this design chapter and in the implementation chapter this part will be
ignored, and rather assume that if you are a direct neighbor of the \ac{SP}, you
are automatically allowed to enter the network and therefore no real
verification of the certificates are done. This must however, be thought through
and most likely changed in a real-world implementation.

\subsection{Authorized Operation}
%Once a node is authorized and has its own \ac{PC1}, it can send its own routing
%announcements, receive announcements, and forward other nodes' announcements.
%This means that the node is a fully worthy member of the MANET. However, there
%is one thing missing before the node can be verified and verify other nodes
%(than the \ac{SP}) - i.e. it has to learn the public key and address of all its
%neighbors.

%Figure \ref{fig:node_states_authorized} shows the authorized node receiving
%an \ac{AL} Update from the \ac{SP}. This message contains the full \ac{AL} list
%and lets the newly authorized node learn the public key and address of
%potential other nodes in the network. The list is broadcasted by the \ac{SP}
%periodically to make sure all nodes in the network know and trust each other.

%\begin{figure}[h]
%	\centering
%  	\includegraphics[width=0.5\textwidth]{images/node_states_authorized.png}
%  	\caption{Normal operation between a \acf{SP} and an unauthenticated node
%  	(A)including an \ac{AL} Update message.}
%	\label{fig:node_states_authorized}
%\end{figure}

When a node has been issed a \ac{PC} and become a trusted node in the network,
it is almost ready to take part in the sending and forwarding of routing
announcements. But before a node can take part in the routing in the network, it
has to be able to append one-time-passwords to its routing announcements, and to
verify other nodes' one-time-passwords as it receives routing announcements from
them.


\subsubsection*{Keystream generation}
The one-time-passwords are actually smaller extracts of large keystream shared
between direct neighbors in the network. When the node started its routing
protocol daemon, before discovering the \ac{SP} in the previous step, it
generated a high entropy pseudo-random master key and a regular pseudo-random
\ac{IV}. At this point, the node will then generate a new ephemeral key by
encrypting $K_{ephemeral} = E_{K_{master}}\{i\}$ where $i = 1,2,3\ldots$ and a
corresponding \ac{IV} generated in the same manner as the previous \ac{IV} for
the master key. In addition a large nonce (about 1000 bytes) is generated with a
pseudo-random function, also in the same manner as the \acp{IV}.

With the current ephemeral key, generated with $i = 1$, \ac{IV} and nonce, the
node can now generate its first keystream to be used as one-time-passwords for
its routing announcements. The keystream is generated by encrypting the nonce
with the ephemeral key multiple times, each time extending the size of the
keystream. In the first encryption the supplied \ac{IV} is used, while in the
next iterations the output of the previous encryption (ciphertext) is used as
\ac{IV} in a \ac{CBC} manner. To lessen any confusion a figure to illustrate
this is in order. Figure \ref{fig:keystream_generation} shows process assuming
the ephemeral key has already been created.

\begin{figure}[h]
	\centering
  	\includegraphics[width=\textwidth]{images/keystream_generation.png}
  	\caption{Keystream generation using a nonce value N times with a simple plus
  		one multiplication. Each nonce will go through full AES-CBC encryption. The
  		keystream output is all the generated ciphertexts appended. The different
  		sizes between IV and nonce are not correct, the nonces are about 60 times
  		larger in size than the IVs.}
	\label{fig:keystream_generation}
\end{figure}

In the figure above there are some boxes marked with ``Full AES-CBC
encryption''. This is meant to illustrate that within each of those boxes there
is a full AES-CBC encryption taking place, with multiple steps according to the
standards of AES-CBC. The reader should also notice that as the ciphertext
output of each of those boxes are much larger than the AES block size,
not coincidentally the same size as an \ac{IV}, only an AES block size at the
end of the ciphertext is used as an \ac{IV} for the next encryption step,
instead of the whole ciphertext which would usually be done in CBC as there the
ciphertext corresponds to the correct block size.

\subsubsection*{Keystream Sharing}
Now, before this keystream can be used to authenticate routing announcements,
the node will have to share the keystream with its direct neighbors. This is
done by sending all the material necessary for the neighbor to create the
keystream themselves and signing the message with your private key. I.e. the
node will have to send the ephemeral key, \ac{IV} and nonce to its neighbor.
Here it is crucial that the key stay secret between the neighbors, therefore
the node will have to encrypt the ephemeral key with its neighbors public keys
and send a unicast message with the keystream material to each one of them. The
details around sharing the keystreams will be further explained in the
following section regarding all messages sent in the network.

\subsubsection*{Using One-Time-Passwords from Keystream}
Once the keystream has been shared with the neighbors, the node will begin to
extract smaller chuncks of the keystream and use an one-time-password for each
routing announcement it generates itself, or forwards from other trusted
neighbors. In addition to the one-time-password appended to the announcements,
the node keeps a counter, or sequence number, to keep track of which
one-time-password it has used in order not to use the password twice.

Similarily the node will have to both verify the correctness of the
one-time-passwords received in announcements from its trusted neighbors, and
that it has not been received before. If the password has been received before
the annoucement has to be dropped, and assumed is part of a replay-attack. If
the node would have accepted re-using of one-time-passwords, an attacker could
listen and record valid one-time-passwords and then re-use them with false
routing information in order to disrupt the routing in the network.

How to check for replayed one-time-passwords is further elaborated in the next
chapter, but simply put a sliding window recording the last announcements are
used, setting a bit value to true if an announcement with the corresponding
sequence number (keystream sequence number, not from original protocol) has been
received, and zero if not.

\subsubsection*{Discovering New Neighbors}
Above, the node only had only discovered the \ac{SP} which after the
authentication handshake shared their keystream material in order to be able to
trust each others routing annoucements. Because of the trust mode being used in
this design, each routing annoucement from the \ac{SP} is trusted, even if they
are re-broadcasts originating from other nodes not yet known to the new node.
This means that the routing table of our node could possibly fill up with
unknown nodes, reachable through \ac{SP}. To have all data streams go through
the \ac{SP} however, would be less than ideal. If some of those nodes are direct
neighbors of our node, they should be able to communicate directly.

Therefore a discovery of other trusted (by the network at least) needs to be
performed. Up till this point, if you receive routing announcements from an
unknown neighbor you would have dropped the packet. After becoming an
authenticated node, the node will now instead engage in a short handshake to
exchange \acp{PC} with the other neighbor. If the neighbor sends you a \ac{PC}
with a signature of the \ac{SP} which you are able to verify.

Again, the verification of the ownership of the \ac{PC} is performed indirectly
when the nodes are about to share their keystream materials. After sharing their
\acp{PC} with each other, they need to share their keystream materials as before
- and this material is signed with the private key of the sender. Therefore,
assuming the nodes has not been compromized, the ownership of the neighbors is
indirectly verified by verifying this signature. Again, this signature is
discussed further in Section \ref{sect:am_messages}.

-TODO: add to protocol that a new neighbor should have been observed through
announcements sent by already trusted nodes. Not just assume if the password is
not null to initiate handshake with that node. Needs to be implemented and
written about. If no time to implement, write aboutin Discussion Chapter
instead!

\section{Detailed Entity Description}
This section describes the different entities in greater detail. How they are
used and why they are present is some of the questions that will be answered.

\subsection{\acf{PC}}


\subsubsection*{\acf{PC0}}

\subsubsection*{\acf{PC1}}

\subsection{\acf{SP}}
The term \acl{SP} was coined by Dr. Lawrie Brown \cite{lawrie:technotes}.
\acp{SP} are used in place of regular \acp{CA} for \acp{PC}. The \ac{SP}
determines whether a node should be issued a \ac{PC} and if so which policies to
attach. The \ac{SP} drastically distinguishes itself from regular \acp{CA}
because it breaks the hierarchical model usually associated with \acp{CA} when
they are part of a \ac{PKI}.

A \ac{SP} can also be part of a \ac{PKI} (issued a regular public key
certificate), but because of our scenario, it can be difficult or impossible to
verify its regular certificate. Therefore, no distinction is made whether the
\ac{SP} has had a regular ``\ac{CA}-signed'' certificate sign its \ac{PC0} or if
its \ac{PC0} is self-signed.


\subsection{\acf{AL}}


\section{Authentication Module Messages}
\label{sect:am_messages}
This section describes the different messages sent within, or modified by, the
\ac{AM} extension. This includes how they are created, what payload they
contain, if and how the information is secured from malicious actors, and
finally to whom and how often they are sent during normal operation.

\subsection{Authentication Handshake}
The authentication handshake describes which messages are sent while
authenticating a new node to the network. The handshake is triggered by the
event where the \ac{SP} discover a new and unauthenticated neighbor node.

\subsubsection*{Node Discovery}
Node discovery is not actually a part of the handshake itself, but it is the
event that triggers the handshake and is described here to make the context more
clear to the reader.

TODO: Write about the neighbor list before this section\ldots

As described earlier each node stores a local copy of the \ac{AL} and a direct
neighbor node list. Whenever a trusted node receives a routing announcement from
a new neighbor, i.e. a node which is not in the direct neighbor list, the
trusted node needs to check the \ac{AL} to see if the node is a trusted node. If
the node can be found in the \ac{AL} the trusted node will request the signature
of the node and store it alongside the address of the node in its neighbor list.

If the node is an unknown node however, regular trusted nodes, i.e. nodes issued
with a \ac{PC1}, will discard the announcement and go on with its other
operations. \acp{SP} will initiate an authentication handshake in the same
event.

\subsubsection*{Handshake Invite}

\subsubsection*{\acf{PC} Request}

\subsubsection*{\acf{PC} Issue}

\subsubsection*{ACK ?}
Maybe share the signature (rand+aes-key) in this ack?



\subsection{Routing Announcement Authentication}
In the ideal world every routing announcement broadcasted on the network would
be signed for authenticity and integrity, but for our scenarios and \acp{MANET}
in general the world is far from ideal.

One huge limitation is packet size - because each routing announcement is
broadcasted throughout the network, and the network in our case is a higly lossy
one, one needs to constrain the packet size or else all the throughput in the
network would be used on routing announcements. The decision was therefore made to
include only a small value of 16 bits to deduce node authentication and to
assume packet integrity.

Later in Section \ref{sect:routing_auth_solution} the idea  behind this
solution is discussed, partly defending why this solution was chosen, and partly
what limitations this solution has compared to more traditional ways.

\subsubsection*{Signature?? Message}

The idea is similar to other \ac{MAC} solutions [TODO: find ref] except only a
special packet sent periodically is verified - instead of each routing announcement.
This packet contains a pseudo-randomly generated value, a temporary symmetric
key generated from the master key, and signed hash value of the packet.

TODO: mention master key here or earlier??

The neighbor receiving the packet first computes a message digest, hash, of the
first part of the packet, and decrypts the signed hash value contained in the
packet and checks to see if they are identical. If so, the neighbor trusts this
packet to be from an actual trusted neighbor.

The packet cannot be broadcasted, because there is no shared group key between
all nodes in the network, but has to be unicasted to each of the direct
neighbors - encrypted with their public keys.

\subsubsection*{Extended Routing Announcements}

The routing announcements are appended with 16 bits of the \ac{MAC} code, which
is the pseudo-random value encrypted with the symmetric key. For each routing
announcement there is a counter, which tells the receiving neighbor at which
offset of the \ac{MAC} value the 16 bits belong to.

Depending on how fast the \ac{MAC} is exhausted, the sender can instruct its
neighbors to create a bigger value based on the same pseudo-random value. For
example the nodes can be instructed to generate a \ac{MAC} ten times the size of
the pseudo-random value - easily done by incrementing and encrypting the random
bytes ten times.

TODO: Add figure showing these messages, and explicitly the 16 bits extracted
from the mac\ldots

For each routing announcement a neighbor receives, he checks the 16 bits at the
given offset of the self-generated \ac{MAC} and if it matches - he assumes the
message is from his trusted neighbor. If any packet contains 16 bits extract
that does not match the \ac{MAC} at the given offset, the packet will be
regarded untrusted and dropped.

\begin{figure}[h]
	\centering
  	\includegraphics{images/mac_ogm_msc.png}
  	\caption{Node A peridically generates a new pseudo-random value and a
  	corresponding symmetric key which it shares with its neighbor B. Node A use
  	an extract of a generated MAC of this value in each of its routing
  	announcements hereafter.}
	\label{fig:mac_ogm_msc}
\end{figure}

\subsubsection*{REWRITE OVER\ldots}
In a typical MAC algorithm you send a message appended with a MAC value. Then
the receiver takes the message, creates his own MAC value and compares it with
the received MAC value\ldots 

In this solution, the first message, find a name for it!, will contain a message
(pseudo-random value), WITHOUT the MAC value. (It must also be encrypted and
signed.,..). 

The MAC value is instead sent with the routing announcements, instead of with
the initial message itself.

Will be rewritten later.

\subsection{\acf{AL}}

\subsubsection*{\acf{AL} Update}

\subsubsection*{\acf{AL} Single Row Update}